// app/api/generate-prompt/route.ts
import { NextResponse } from "next/server";
import OpenAI from "openai";

export const runtime = "edge";

function toDataUrl(file: File) {
  return new Promise<string>((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = () => reject(new Error("Failed to read file"));
    reader.onload = () => resolve(reader.result as string);
    reader.readAsDataURL(file);
  });
}

export async function POST(req: Request) {
  try {
    const form = await req.formData();
    const name = (form.get("name") as string) || "Untitled";
    const image = form.get("image") as File | null;

    const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

    const parts: any[] = [
      {
        type: "text",
        text:
          `Analyze the image and produce a clean, reusable prompt for a generative AI UI.\n` +
          `- Return only the prompt text (no quotes, no bullets, no preamble).\n` +
          `- The prompt should be specific and self-contained.`,
      },
    ];

    if (image && typeof image === "object") {
      const dataUrl = await toDataUrl(image);
      parts.push({ type: "image_url", image_url: { url: dataUrl } });
    }

    const chat = await client.chat.completions.create({
      model: process.env.OPENAI_MODEL || "gpt-4o-mini",
      messages: [{ role: "user", content: parts as any }],
      temperature: 0.3,
    });

    const promptText = (chat.choices?.[0]?.message?.content || "").trim();
    if (!promptText) throw new Error("Model returned empty content.");

    const now = new Date().toISOString();

    return NextResponse.json({
      id: crypto.randomUUID(),
      title: name,
      description: "Generated by OpenAI from your image.",
      imageUrl: image ? "data:uploaded" : undefined,
      prompt: promptText,
      favorite: false,
      createdAt: now,
    });
  } catch (err: any) {
    return new NextResponse(err?.message || "Failed to generate", { status: 500 });
  }
}